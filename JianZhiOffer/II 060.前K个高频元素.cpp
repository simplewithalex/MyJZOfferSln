#include "header.h"

/*

LCR 060. 前 K 个高频元素

给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素
你可以按 任意顺序 返回答案

示例 1:
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]

示例 2:
输入: nums = [1], k = 1
输出: [1]

提示：
1 <= nums.length <= 10^5
k 的取值范围是 [1, 数组中不相同的元素的个数]
题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的

进阶：你所设计算法的时间复杂度 必须 优于 O(nlogn) ，其中 n 是数组大小

注意：本题与主站 347 题相同：https://leetcode-cn.com/problems/top-k-frequent-elements/

*/


class Solution {
private:
	static bool compare(pair<int, int> &p1, pair<int, int> &p2) {
		return p1.second > p2.second;
	}

public:
	vector<int> topKFrequent(vector<int> &nums, int k) {
		unordered_map<int, int> occurrences;
		for (const int &n : nums) ++occurrences[n];
		priority_queue<pair<int, int>, vector<pair<int, int>>,
			decltype(compare) *> pq(compare);
		for (const auto &p : occurrences) {
			pq.push(p);
			if (pq.size() > k) pq.pop();
		}
		vector<int> res;
		while (!pq.empty()) {
			res.push_back(pq.top().first);
			pq.pop();
		}
		return res;
	}
};
